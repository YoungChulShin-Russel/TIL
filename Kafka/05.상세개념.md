# 상세개념
## 토픽, 파티션
### 적정 파션 개수
데이터 처리량을 올리는 방법
1. 컨슈머의 처리량을 올리는 방법
2. 컨슈머를 추가해서 병렬처리량을 늘리는 방법

이론적으로는 `'프로듀서 전송량 < 컨슈며 처리량 * 파티션 개수'` 이면된다
- 컨슈머의 처리량은 상용에서 더미데이터를 이용해서 확인힌다. 로컬과 상용의 환경차이가 있을 수 있기 때문에 상용에서 테스트를 해본다. 

메시지키를 사용하는데, 중간에 파티션이 변경되면 메시지 키의 순서를 보장받지 못할 수 있다
- 파티션 개수가 달라지는 순간에는 변환하기 전/후로해서 메시지키의 파티션 위치가 달라지기 때문이다

메시지키를 사용하고 컨슈머에서 처리순서가 보장되어야한다면 파티션의 변화가 발생하지 않는 방향으로 가야한다
- 파티션의 개수를 처음부터 넉넉하게 잡고 생성하는 방법이 있다
- 만약에 순서가 중요하지 않다면, 처음부터 파티션의 수를 넉넉하게 잡지 않아도 된다

브로커당 파티션 개수를 모니터링해야한다
- 파티션이 늘어나면 브로커가 접근해야하는 파일수가 많아진다. OS에서는 프로세스당 열 수 있는 파일 최대개수를 제한하고 있기 때문에 모니터링이 필요하다
- 브로커가 관리하는 파티션의 수가 너무 많다면 파티션 수를 분산하기 위해서 브로커수를 늘리는것도 하나의 방법이다

### 토픽 정리 정책
토픽 삭제 정책 (delete policy)
- 세그먼트 단위로 토픽의 데이터를 삭제한다
   - 세그먼트: 토픽의 데이터를 저장하는 명시적인 파일시스템 단위. 파티션마다 별개로 생성되면 파티션의 이름은 오프셋중 가장 작은 값이된다. 
   - 액티브 세그먼트: 데이터를 저장하기 위해서 사용중인 세그먼트
   - `segment.bytes` 크기보다 커질 경우에는 세그먼트 파일을 닫고, 새로운 세그먼트를 열어서 데이터를 저장한다
- 삭제 정책
   - `retention.ms`: 세그먼트의 마지막 수정 시간이 이 값을 넘어가면 삭제된다
   - `retention.bytes`: 토픽의 최대 데이터 크기를 제어한다. 이 값을 넘어간 세그먼트 파일들은 삭제된다

토픽 압축 정책 (compact policy)
- 압축이란 메시지 키 별로 레코드 중 오래된 데이터를 삭제하는 정책
- 메시지키를 기준으로 오래된 데이터를 삭제하기 때문에 오프셋 증가가 일정하지 않을 수 있다
   - 예: 0-10 오프셋에서 4,5,6이 같은 키를 가지고 있다면 4,5가 삭제된다
- 액티브 세그먼트를 제외한 나머지 세그먼트들에 한해서 처리된다

### ISR(In-Sync-Replicas)
ISR
- 리더파티션과 팔로워파티션이 모두 싱크가 된 상태를 말한다. 즉, 리더파티션에 있는 모든 오프셋이 팔로워파티션에도 있게된다
- ISR이 나온 이유는 팔로워파티션이 리더파티션으로부터 데이터를 복제하는데 시간이 걸리기 때문이다

만약 `replica.lag.time.max.ms` 값보다 긴 시간동안 데이터를 가져가지 않는다면 팔로워파티션에 문제가 생긴걸로 판단하고 ISR그룹에서 제외한다
- ISR 그룹으로 묶여있어야지 리더파티션에 문제가 생겼을 때, 팔로워파티션이 리더로 선출될 자격을 가진다

`unclean.leader.election.enable`
- false: ISR이 아닌 팔로워 파티션을 리더로 선출하지 않는다
   - ISR 팔로워중에서 동기화가 모두 된 항목이 있다면 리더로 선출
   - 팔로워가 없다면 리더파티션이 존재하는 브로커가 다시 실행될 때까지 서비스 중지가 발생한다. 
   - 데이터 유실은 일어나지 않는다
- true: ISR이 아닌 팔로워파티션도 리더로 선출될 수 있다
   - 서비스 중단이 발생하지 않는다
   - 데이터 유실이 일어날 수 있다
