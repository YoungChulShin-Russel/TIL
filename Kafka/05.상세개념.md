# 상세개념
## 토픽, 파티션
### 적정 파션 개수
데이터 처리량을 올리는 방법
1. 컨슈머의 처리량을 올리는 방법
2. 컨슈머를 추가해서 병렬처리량을 늘리는 방법

이론적으로는 `'프로듀서 전송량 < 컨슈며 처리량 * 파티션 개수'` 이면된다
- 컨슈머의 처리량은 상용에서 더미데이터를 이용해서 확인힌다. 로컬과 상용의 환경차이가 있을 수 있기 때문에 상용에서 테스트를 해본다. 

메시지키를 사용하는데, 중간에 파티션이 변경되면 메시지 키의 순서를 보장받지 못할 수 있다
- 파티션 개수가 달라지는 순간에는 변환하기 전/후로해서 메시지키의 파티션 위치가 달라지기 때문이다

메시지키를 사용하고 컨슈머에서 처리순서가 보장되어야한다면 파티션의 변화가 발생하지 않는 방향으로 가야한다
- 파티션의 개수를 처음부터 넉넉하게 잡고 생성하는 방법이 있다
- 만약에 순서가 중요하지 않다면, 처음부터 파티션의 수를 넉넉하게 잡지 않아도 된다

브로커당 파티션 개수를 모니터링해야한다
- 파티션이 늘어나면 브로커가 접근해야하는 파일수가 많아진다. OS에서는 프로세스당 열 수 있는 파일 최대개수를 제한하고 있기 때문에 모니터링이 필요하다
- 브로커가 관리하는 파티션의 수가 너무 많다면 파티션 수를 분산하기 위해서 브로커수를 늘리는것도 하나의 방법이다

### 토픽 정리 정책
토픽 삭제 정책 (delete policy)
- 세그먼트 단위로 토픽의 데이터를 삭제한다
   - 세그먼트: 토픽의 데이터를 저장하는 명시적인 파일시스템 단위. 파티션마다 별개로 생성되면 파티션의 이름은 오프셋중 가장 작은 값이된다. 
   - 액티브 세그먼트: 데이터를 저장하기 위해서 사용중인 세그먼트
   - `segment.bytes` 크기보다 커질 경우에는 세그먼트 파일을 닫고, 새로운 세그먼트를 열어서 데이터를 저장한다
- 삭제 정책
   - `retention.ms`: 세그먼트의 마지막 수정 시간이 이 값을 넘어가면 삭제된다
   - `retention.bytes`: 토픽의 최대 데이터 크기를 제어한다. 이 값을 넘어간 세그먼트 파일들은 삭제된다

토픽 압축 정책 (compact policy)
- 압축이란 메시지 키 별로 레코드 중 오래된 데이터를 삭제하는 정책
- 메시지키를 기준으로 오래된 데이터를 삭제하기 때문에 오프셋 증가가 일정하지 않을 수 있다
   - 예: 0-10 오프셋에서 4,5,6이 같은 키를 가지고 있다면 4,5가 삭제된다
- 액티브 세그먼트를 제외한 나머지 세그먼트들에 한해서 처리된다

### ISR(In-Sync-Replicas)
ISR
- 리더파티션과 팔로워파티션이 모두 싱크가 된 상태를 말한다. 즉, 리더파티션에 있는 모든 오프셋이 팔로워파티션에도 있게된다
- ISR이 나온 이유는 팔로워파티션이 리더파티션으로부터 데이터를 복제하는데 시간이 걸리기 때문이다

만약 `replica.lag.time.max.ms` 값보다 긴 시간동안 데이터를 가져가지 않는다면 팔로워파티션에 문제가 생긴걸로 판단하고 ISR그룹에서 제외한다
- ISR 그룹으로 묶여있어야지 리더파티션에 문제가 생겼을 때, 팔로워파티션이 리더로 선출될 자격을 가진다

`unclean.leader.election.enable`
- false: ISR이 아닌 팔로워 파티션을 리더로 선출하지 않는다
   - ISR 팔로워중에서 동기화가 모두 된 항목이 있다면 리더로 선출
   - 팔로워가 없다면 리더파티션이 존재하는 브로커가 다시 실행될 때까지 서비스 중지가 발생한다. 
   - 데이터 유실은 일어나지 않는다
- true: ISR이 아닌 팔로워파티션도 리더로 선출될 수 있다
   - 서비스 중단이 발생하지 않는다
   - 데이터 유실이 일어날 수 있다

## 카프카 프로듀서 
### ack 옵션
ack=0
- 프로듀서가 리더 파티션으로 데이터를 전송할 때, 리더파티션으로 데이터가 저장되었는지를 확인하지 않는다
- 프로듀서는 `retries` 옵션으로 데이터를 재전송 할 수 있는데, ack=0이면 데이터를 전송하자마자 저장되었음을 가정하기 때문에 전송이 실패한 경우를 알 수 없다
- 데이터가 유실될 수 있다
- 브로커에 데이터가 적재되었는지를 확인하지 않기 때문에 속도는 1, all보다 빠르다

ack=1
- 프로듀서가 보낸 메시지가 리더 파티션에만 정상적으로 저장되었는지 확인한다
- 유실은 발생할 수 있다
   - 리더파티션으로 데이터를 보낸뒤에, 팔로워파티션이 데이터를 복제하기 전에 리더파티션이 죽을 경우

ack=all or ack=-1
- 프로듀서가 보낸 데이터가 리더, 팔로워 파티션에 모두 적재되었는지 확인한다
- 속도가 제일 느리다
- 브로커에 장애가 발생해도 데이터 유실은 발생하지 않는다
- `min.insync.replicas` 옵션: 최소한의 ISR 그룹 파티션 개수
   - 옵션 값이 1이라면 리더파티션만 ISR에 포함하기 때문에 ack=1로 했을 때와 동일하다
   - 브로커의 수가 이 옵션보다 작거나 동일할 경우에는 문제가 발생할 수 있다
      - 예를 들어서 3대의 브로커가 운영중이고, 옵션을 3으로 주면 항상 3대가 복제되어야하는데, 1대의 브로커에 장애가 발생하면 해당 브로커가 동작할 때까지 기다려야한다. ack=all인 상태에서는 데이터 동기화가 되지 않기 때문에 프로듀서가 데이터를 전송할 수 없다. 

### 멱등성(idempotence) 프로듀서
기본 프로듀서의 동작 방식은 `적어도 한번 전달(at least once delivery)`를 사용한다. 
- 한번 이상 데이터가 적재될 수 있고 데이터가 유실되지는 않는다. 중복이 발생할 수 있다

`enable.idempotence` 옵션: 멱등성 프로듀서 활성화 옵션. 기본값은 false
- 0.11.0 이후에 지원
- 데이터를 전달 할 때, `프로듀서 PID`와 `시퀀스 넘버`를 보낸다. 브로커는 PID와 시퀀스번호를 확인해서 동일한 메시지의 적재요청이 오더라도 한번만 적재되도록 동작한다. 
- 제약 사항
   - 프로듀서가 동일한 세션에서만 정확히 한번 전달을 보장한다. 프로듀서 애플리케이션이 재시작되면 PID가 달라진다. 
   - 옵션이 활성화 되면 `retries` 는 'Integer.MAX_VALUE'로 설정되고, `ack` 옵션은 'all'로 설정된다.
- 브로커에서 PID와 시퀀스를 확인하는 과정에서 시퀀스 넘어가 일정하지 않은 경우에는 `OutOfOrderSequenceException`이 발생할 수 있다.
   - 순서가 중요한 데이터를 전송하는 프로듀서는 해당 예외를 핸들링해줘야한다

### 트랜잭션 프로듀서
컨슈머는 기본적으로 프로듀서가 보내는 데이터가 파티션에 쌓이는대로 모두 가져가서 처리한다. 

트랙잭션으로 묶어서 데이터를 가져가도록 처리할 수 있다
- 설정
   - `enable.idempotence`: true
   - `transactional.id` 값을 임의의 String으로 정의한다
   - 컨슈머의 `isolation.level`을 'read_committed'로 설정한다
- 처리 방법
   - 트랜잭션은 파티션의 레코드로 구분한다
   - 프로듀서는 트랜잭션의 시작과 끝을 표현하기 위해서 트랜잭션 레코드를 하나 더 보낸다
   - 컨슈머는 트랜잭션 레코드가 없으면 데이터를 가져가지 않고 기다린다
      ![4-2-3-2](/kafka/assets/4-2-3-2.png)