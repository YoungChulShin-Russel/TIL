# 기본 개념
카프카 브로커
- 카프카 클라이언트와 데이터를 주고 받기 위해 사용하는 주체
- 하나의 서버에 한개의 브로커 프로세스가 실행
- 1대로도 동작하지만 보통 고가용성을 위해서 3대 이상의 브로커 서버를 1개의 클러스터로 묶어서 사용한다
- 데이터는 파일 시스템에 저장한다. 메모리, DB, 캐시 메모리를 사용하지 않는다. 
   - 속도 문제는 페이지캐시(OS에서 파일 입출력의 성능 향상을 위해 만들어 놓은 메모리 영역)를 사용하여 문제를 해결

카프카 클러스터
- n개의 카프카 브로커의 그룹
- 저장 데이터
   - 브로커 정보
   - 컨트롤러 정보
   - 토픽 정보
- tree 구조의 znode(데이터 저장 단위)로 관리된다

주키퍼
- 카프카의 메타데이터를 관리한다

데이터 복제
- 파티션 단위로 일어난다
- 복제 개수가 2개 이상이면 리더, 팔로워 파티션으로 나뉜다
   - 리더는 프로듀서, 컨슈머와 직접 통신하는 파티션
   - 팔로워는 리더 파티션의 오프셋을 확인하고 리더파티션으로 부터 데이터를 가져와서 자신의 파티션에 저장한다

컨트롤러
- 클러스터의 다수 브로커중 한대가 컨트롤러의 역할을 한다
- 컨트롤러는 브로커들의 상태를 체크하고 브로커가 클러스터에서 빠지면 리더파티션을 재분배한다

데이터 삭제
- 컨슈머가 데이터를 가져가더라도 삭제되지 않으며, 컨슈머나 프로듀서가 데이터를 삭제요청 할 수도 없다
- '로그 세그먼트'라는 파일 단위로 삭제가 이루어진다.

컨슈머 오프셋 저장
- 특정 파티션으로부터 데이터를 가져가고 오프셋을 커밋한다
- 커밋한 오프셋은 `'_consumer_offsets'` 토픽에 저장한다

코디네이터
- 클러스터의 다수 브로커 중 한 대는 코디네이터 역할을 수행한다
- 코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할을 한다
   - 컨슈머가 컨슈머그룹에서 빠지면 매칭되지 않는 파티션을 정상 동작하는 컨슈머로 할당하여 데이터가 처리되도록 한다
   - 이 과정을 리밸런싱이라고 한다
