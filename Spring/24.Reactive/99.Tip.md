## 동기 방식의 코드를 논블록킹 동기 API로 변경
Step1. Repository를 ReactiveCrudRepository로 변경

변경 전 코드
```java
public interface RecommendationRepository extends CrudRepository<RecommendationEntity, String> {

  List<RecommendationEntity> findByProductId(int productId);
}
```

변경 후 코드
```java
public interface RecommendationRepository extends
    ReactiveCrudRepository<RecommendationEntity, String> {

  Flux<RecommendationEntity> findByProductId(int productId);
}
```

Step2. Repository를 사용하는 코드에서 Stream 기반으로 변경

변경 전 코드
```java
@Override
public Recommendation createRecommendation(Recommendation body) {
  try {
    RecommendationEntity entity = recommendationMapper.apiToEntity(body);
    RecommendationEntity newEntity = recommendationRepository.save(entity);

    return recommendationMapper.entityToApi(newEntity);
  } catch(DuplicateKeyException dke) {
    throw new InvalidInputException("Duplicate key, Product Id: " + body.getProductId() + ", Recommendation Id:" + body.getRecommendationId());
  }
}

@Override
public List<Recommendation> getRecommendations(int productId) {
  if (productId < 1) {
    throw new InvalidInputException("Invalid productId: " + productId);
  }

  List<RecommendationEntity> entityList = recommendationRepository.findByProductId(productId);
  List<Recommendation> recommendationList = recommendationMapper.entityListToApiList(entityList);
  recommendationList.forEach(r -> r.updateServiceAddress(serviceUtil.getServiceAddress()));

  LOG.debug("/recommendation response size: {}", recommendationList.size());

  return recommendationList;
}

@Override
public void deleteRecommendations(int productId) {
  recommendationRepository.deleteAll(recommendationRepository.findByProductId(productId));
}
```

변경 후 코드
```java
@Override
public Recommendation createRecommendation(Recommendation body) {
  if (body.getProductId() < 1) {
    throw new InvalidInputException("Invalid productId: " + body.getProductId());
  }

  RecommendationEntity entity = recommendationMapper.apiToEntity(body);
  Mono<Recommendation> newEntity = recommendationRepository.save(entity)
      .log()
      .onErrorMap(
          DuplicateKeyException.class,
          ex -> new InvalidInputException(
              "Duplicate key, Product Id: " + body.getProductId() +
                  ", Recommendation Id:" + body.getRecommendationId()))
      .map(e -> recommendationMapper.entityToApi(e));

  return newEntity.block();
}

@Override
public Flux<Recommendation> getRecommendations(int productId) {
  if (productId < 1) {
    throw new InvalidInputException("Invalid productId: " + productId);
  }

  return recommendationRepository.findByProductId(productId)
      .log()
      .map(e -> recommendationMapper.entityToApi(e))
      .map(e -> {
        e.updateServiceAddress(serviceUtil.getServiceAddress());
        return e;
      });
}

@Override
public void deleteRecommendations(int productId) {
  if (productId < 1) {
    throw new InvalidInputException("Invalid productId: " + productId);
  }

  recommendationRepository
      .deleteAll(recommendationRepository.findByProductId(productId))
      .block();
}
```