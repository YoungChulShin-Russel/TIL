# 테스트 주도 개발 기초
## 코드 기능 명세
도메인
- 소프트웨어가 풀어야할 문제가 정의되는 공간
- 문제를 잘 이애하지 못하면 문제를 푸는 도구(소프트웨어)를 잘 만들 수 없다. 그래서 도메인을 잘 이해해야한다. 
- 프로그래머가 충분히 명확한 도메인 지식을 확보하지 못했다면 지힉 흐름 상류(비지니스 전문가, 분석가)에게 요청해야한다. 스스로 결정을 내리면 지식에 오차가 발생하거나 도박 행위일 수 있다. 

## 테스트 기법
수동 테스트
- 품질 담당자가 UI를 사용해 기능을 검증
- 실행 비용이 높고 가장 온전한 코드 실행
- 기능이 b -> c로 개발되었는데, 영향이 a -> b도 받을 수 있지만, 테스트는 이 부분을 제한적으로 하거나 스킵한다. 

테스트 자동화
- 기능을 담당하는 코드를 작성
- 실행 비용이 낮고 결과의 신뢰도가 높다
- 테스트 코드 작성/관리가 프로그래머의 역량에 크게 영향을 받는다

인수테스트
- 배치된 시스템을 대상으로 검증
- 쩐체 시스템 이상 여부 신뢰도가 높으나 비용도 높고, 피드백 품질이 낮다. (현상은 드러나지만 원인은 숨겨짐)

단위 테스트
- 시스템의 일부를 대상으로 검증
- 비용이 낮고 피드백 품질이 높으나 전체 시스템 이상 여부 신뢰도가 낮다

## 코드 분해
모듈
- 인터페이스와 구현으로 분리
- 재사용 될 때에는 인터페이스를 보면서 재사용한다

## 단위 테스트
반복되는 테스트라면 for문이나 반복테스트로 반복을 줄이자. 대신 어떤 값이 실패했는지 알아야한다. > ParameterizedTest

## 테스트 우선 개발
운용코드보다 테스트코드를 먼저 작성
- 명확하고 검증 가능한 목표를 설정한 후에 목표를 달성
- 코드를 작성하기에 앞서 어떤 방법으로 풀어야하는지를 확실히 이해해야한다

## 정리된 코드
리팩터링
- 의미를 유지하며 코드 베이스르르 정리하는 것. 의미가 변하지 않는게 중요하다.
- 예: x^2-4를 (x-2)(x+2)로 분리

테스트가 잘 작성되어 있으면 의미가 변하지 않는지 확인하면서 리팩터링을 할 수 있다. 

리팩터링 작업 내용
- 기능을 작은 함수로 분리
- 3항 연산자 사용
- 라이브러리에서 제공해주는 기능이 있으면 사용
- 복수 연산은 메서드명을 복수로 하고, 내부적으로 반복되는 수행 코드를 다시 단수의 의미를 가지는 메서드로 분리
- 가능하면 반복 작업이 없도록

## 테스트 주도 개발
개발 절차
- RED: 실패하는 테스트 추가
   - 테스트가 성공하면 단위 테스트를 다시 작성한다
- GREEN: 테스트 통과. 최소한의 코딩
   - 테스트를 통과할 수 있는 가장 빠르고 간단하게 수정한다
- REFACTOR: 구현 설계 개선. 테스트 통과 유지

켄트벡의 설계 규칙
- Passes the tests
- Reveals intention
- No duplication
- Fewest elements (앞에 설명한 3가지의 기능을 제외한 코드는 최소화)

TDD의 비용 (기능 1개를 개발하는)
- TDD를 사용하지 않으면 시간이 지날 수록 비용이 증가한다
- TDD를 사용하면 초기 비용은 TDD를 사용하지 않을 때 보다 높지만, 시간이 지나도 비용이 일정하게 유지된다
- 시간 정보
   - t1: tdd 사용이 tdd 사용을 하지 않을 때 보다 비용이 더 싸지는 시점
   - t2: tdd 사용이 tdd 사용을 하지 않을 때 보다 시간 총 합의 비용이 더 싸지는 시점
- tdd 사용여부는 프로젝트의 수명이 t2보다 클 경우에 도입을 해야한다
- 프로그래머의 역량이나 도구의 지원을 통해서 t2를 줄일 수 있다

## 프로그래머 피드백
프로그래머는 가끔 요구사항 외에 성능 달성이나 구현 설계 개선 같은 개발자의 만족도를 높일 수 있는 부분에 빠져드는 경향이 있다. 이 자체가 나쁜것은 아니나 제일 중요한 것은 목표 달성이이 때문에 여기에 가장 집중을 해야한다. 

TDD의 핵심은 정해진 절차가 아니라 짧은 주기로 지속되는 피드백이다. 

## 장난감
Red-Green-Refactor
- Red -> Green 과정에서는 하드 코딩을 통해서라도 Green을 만든다
- 검증된 테스트 코드의 도움을 받아서 리팩토링하면서 수정한다

public에 대한 테스트
- 메서드 단위가 아니라 동작에 대해서 테스트를 하기 때문에 public에 대해서만 테스트가 만들어진다

반복되는 코드는 메서드 또는 변수로 분리한다

# 테스트 주도 개발의 깊은 곳
## 인터페이스와 구현
대부분의 코드는 다른 코드와 협력한다. 

협력은 무엇과 어떻게 할지로 정의되는데, 아래와 같이 비유할 수 있다.
- 무엇: interface
- 어떻게: 구체적인 구현

정보 숨김
- 변경 가능성이 있는 부분을 숨긴다.

## 환경 변화와 적응력
OOP
- 상속, 캡슐화, 다형성 등의 특징이 있지만 지연된 바인딩 이라는 의미가 이를 잘 표현한다. 
   - 지연된 바인딩이라는 것은 구체적인 객체가 인터페이스에 맵핑되는 시점을 늦춘다는 것을 말한다
- 다형성과도 비슷하게 볼 수 있다

OCP
- 다형적 OCP
- 기능을 추가해도 코드의 변경이 없어야 한다. 
   - 물론 어딘가에 변경은 있겠지만, 그 변경을 최소화해야한다
   - 구체적인 구현체가 있다면 파라미터로 분리하고, 의존성 주입이 가능하도록 한다. 

Testability
- 테스트 가능성이 아니라 테스트 용이성이다

## 입력과 출력
입력은 직접 입력과 간접 입력으로 나뉜다
- 직접 입력: 공개된 interface를 통해서 입력 받는 것
- 간접 입력: interface를 통해서 주입된 객체가 응답을 만들어내는 것

부작용
- 인터페이스 설계에 드러나지 않는 출력
- 예: exception, 지연, 간접 출력(?)

### 옵션 - OOP
캡슐화
- 내부 구현을 숨기기 때문에 한곳의 변경 사항이 다른 곳으로 영향을 주지 않는다
   - 반대의 절차 지향이라면 데이터 중심으로 여러 곳에서 기능 구현이 만들어지기 때문에 기능이 변경되면 변경할 곳이 많아진다
   - 절차지향에서는 데이터에 의존했다면, 객체지향에서는 메서드에 의존한다
- Don't tell ask, Law of Demeter

다형성
- 한 객체가 여러 타입을 가질 수 있는 것

추상화
- 의미가 비슷한 개념이나 표현으로 정의하는 것
- 예: FTPFileDownloader, SocketLogReader, LogGateway -> LogCollector
- 구현체를 수정하더라도 interface가 협력하는 곳에는 수정이 없기 때문에 변경되는 부분을 줄일 수 있다
- 방법: 변화되는 부분을 추상화

상속
- 구현 상속은 상위 클래스의 변경이 하위 클래스에 영향을 줄 수 있기 때문에 사용에 주의해야 한다. 기능이 복잡해지면 하위 클래스가 많아 질 수도 있다. 
- 재사용이 아닌 기능의 확장 (IS-A) 관계에 사용해야 한다.

## 테스트 대역
DOC
- Depended on Component
- Test 하려는 대상 코드가 의존하는 코드
- 외부 시스템을 의존하고 있다면 테스트가 어려울 수 있다
- Interface를 준수하는 코드로 대체해서 테스트한다. 이 경우 비슷한 동작을 할 것이라고 가정한다. 

종류
- dummy: sut 준비를 위한 의존성이지만 테스트에는 필요하지 않는 의존성
- stub: 간접 입력 대역. 미리 준비된 답을 출력. 테스트를 위해서 원하는 데이터를 리터한다. 
- spy: 간접 출력. 출력을 임시로 기록하고, 이 방법으로 출력이 되는지 확인한다
   - 예: Logger에 로그 메시지를 기록하는 방법으로 할 수 있을 것 같다. 
- mock: sut 내부의 행위를 검증
- fake: 의존성 계약을 준수하는 가벼운 형태의 구현체. DoC보다는 적은 부작용을 가지고 있다.
   - 예: 인메모리 DB

## __Mockist vs Classist__
Doc가 테스트대역으로 대체될 수록 가정의 안정성은 낮아진다. 

Mock의 위험
- Test가 sut 구현에 의존한다. Test를 작성하는 시점에 구현에 대해서 생각하게 된다. 어떻게 동작을 제어할지를 알고 있어야하기 때문이다. 
- mock은 '요구 사항을 만족' + '어떻게 만족'을 다룬다
   - 코드를 리팩토링 할 때 '어떻게'가 깨질 수 있다. -> 리팩토링을 주저한다
- 코드의 가독성이 좋지않고, mock을 위한 코드들이 들어간다. 
- classist는 결과에 대해서 검증하는데, mockist는 mock 동작이 제대로 되었는지 검증한다.

Test의 범위
- mock을 사용하면 그 범위가 줄어들고, 
- DoC를 사용하면 넓어진다

## Private Method Test
Test가 공개된 Interface가 아니라 숨겨진 모듈에 의존하게 된다. 
- Private Method는 요구 사항이 아니기 때문이다
- 리팩토링 과정에서 Private 메서드는 쉽게 변경될 수 있는데, 이때마다 테스트 코드를 수정하는 작업이 필요하다

## Test-Driven-Design
TDD의 시작은 운영 코드의 인터페이스가 만들어지는 시점에서 시작한다. 

테스트코드는 Interface를 기준으로하기 때문에 구현이 바뀌어도 테스트는 돌아간다.

테스트는 인터페이스의 첫 고객이기 때문에 테스트 작성이 어려우면 인페이스 설계가 잘못된 것이 아닐까 생각해봐야한다. 


# 그냥 생각
sut
- sut로 테스트를 한다는 것은 각각의 메서드에 테스트 의미를 두는게 아니라, 클래스가 하나의 책임을 가지고 있고 그 책임에 대해서 테스트를 하는 것
- 태스트하는 sut의 테스트 범위에 대해서 알고 있어야 한다
- 2개 이상의 책임이 있다면 Test가 어색해 보일 것 같다. 

interface가 잘 분리되어 있다면 mock 도움 없이도 테스트를 잘 할 수 있을 것 같다. 

기능 분리
- 리팩토링 과정에서 기능을 다른 클래스로 분리할 때 기능이 명확하다면 일단 클래스로 분리해보자. 