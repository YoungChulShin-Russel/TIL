# 대규모 서비스 설계를 위한 백엔드 에센셜
## 서킷브레이커
개념
- 말 그대로 회로 차단기의 역할
- __API 호출이 계속 실패할 때 빠르게 실패할 수 있도록 실패 응답을 주는 기능 (=fast fail back)__ 

빠른 실패가 필요한 이유
- 특정 API가 요청을 받았을 때 내부적으로 4개의 서비스를 비동기로 호출한다고 가정하자.
- 평소에는 각 서비스가 20ms 정도로 오기 때문에 전체 응답도 20ms로 유지된다. 
- 하지만 특정 서비스에서 장애가 발생해 300ms의 timeout이 발생했다면 어떻게 될까?
- 정상적인 서비스는 20ms의 응답을 주지만, 장애서비스로 인해서 API의 전체 응답은 300ms가 된다. 
- API를 호출한 Caller 입장에서는 1분에 호출할 수 있는 서비스의 수가 300개에서 20개로 줄어들게 된다. 
- 장애는 전파되기 때문에 Caller를 호출하는 또 다른 Caller도 응답 지연 문제를 겪게 된다. 
- __이 경우 문제되는 시스템에서 바로 실패를 하도록 처리를 하면 1ms의 응답이 될 것이고, 해당 시스템의 결과는 문제가 있지만 전체 시스템은 20ms의 시간을 가져가게 된다__

필수 API와 필수 API가 아닌 것과의 선택이 필요하다
- 예: 커머스 시스템에서 결제가 실패하면? -> fast fail이 아니라 정상 실패를 해야한다
- 예: 메인 페이지에서 추천 카테고리가 실패하면? -> 서비스에 필수 API는 아니기 때문에 fast fail 되도록 할 수 있다
- __'서킷브레이커는 필수적이지 않은 API에서 오류가 발생할 때 이를 어떻게 처리해야 서비스에 영향을 낮출 수 있을까?' 에 대한 고민에서 나온 방법__

상태
- closed: 정상
- open: 일정 시간동안 API 호출을 바로 실패하는 상태
- half open: 일정 시간 이후에 다시 호출해보는 것 

java의 경우 hystrics(관리 X)나 resilience4j 등의 라이브러리를 사용해도 되고, wrapper class를 이용해도 간단하게 구현 가능하다. 